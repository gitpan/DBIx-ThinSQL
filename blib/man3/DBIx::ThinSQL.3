.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::ThinSQL 3"
.TH DBIx::ThinSQL 3 "2013-05-20" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::ThinSQL \- A lightweight SQL helper for DBI
.SH "VERSION"
.IX Header "VERSION"
0.0.2 (yyyy-mm-dd) development release.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use strict;
\&    use warnings;
\&    use DBIx::ThinSQL qw/ bv qv /;
\&
\&    my $db = DBIx::ThinSQL\->connect(
\&        \*(Aqdbi:Driver:...\*(Aq
\&        \*(Aqusername\*(Aq,
\&        \*(Aqpassword\*(Aq,
\&    );
\&
\&    # Some basic CrUD statements to show the simple stuff first. Note
\&    # the inline binding of data that you normally have to call
\&    # $dbh\->bind_param() on.
\&
\&    my $success = $db\->xdo(
\&        insert_into => \*(Aqactors\*(Aq,
\&        values      => {
\&            id    => 1,
\&            name  => \*(AqJohn Smith\*(Aq,
\&            photo => bv( $image, DBI::SQL_BLOB ),
\&        },
\&    );
\&
\&    # A "where" with a HASHref "AND"s the elements together
\&
\&    my $count = $db\->xdo(
\&        update => \*(Aqactors\*(Aq,
\&        set    => { name => \*(AqJack Smith\*(Aq },
\&        where  => { id => 1, name => \*(AqJohn Smith\*(Aq },
\&    );
\&
\&    # A "where" with an ARRAYref concatenates items together. Note the
\&    # string that is quoted according to the database type.
\&
\&    my $count = $db\->xdo(
\&        delete_from => \*(Aqactors\*(Aq,
\&        where       => [
\&            \*(Aqactor_id = 1\*(Aq, \*(Aq OR \*(Aq,
\&            \*(Aqlast_name != \*(Aq, qv("Jones", DBI::SQL_VARCHAR ),
\&        ],
\&    );
\&
\&    # Methods for reading from the database depend on the type of
\&    # structure you want back: array or hash references.
\&
\&    my $ref = $db\->xhash(
\&        select => [ \*(Aqid\*(Aq, \*(Aqname\*(Aq, qv("Some string") ],
\&        from   => \*(Aqactors\*(Aq,
\&        where  => [
\&            \*(Aqid = \*(Aq, qv( 1, DBI::SQL_INTEGER ),
\&            \*(Aq AND photo IS NOT NULL\*(Aq,
\&        ],
\&        limit  => 1,
\&    );
\&
\&    $db\->xdo(
\&        insert_into => [ \*(Aqtable\*(Aq, \*(Aqcol1\*(Aq, \*(Aqcol2\*(Aq, \*(Aqcol3\*(Aq ],
\&        select => [ \*(Aqt1.col3\*(Aq, \*(Aqt3.col4\*(Aq, bv( \*(Aqvalue\*(Aq, DBI::SQL_VARCHAR ) ],
\&        from   => \*(Aqtable AS t1\*(Aq,
\&        inner_join => \*(Aqother_table AS t2\*(Aq,
\&        on         => \*(Aqt1.something = t2.else\*(Aq,
\&        left_join  => \*(Aqthird_table AS t3\*(Aq,
\&        on    => [ \*(Aqt3.dont = t1.care AND t1.fob = \*(Aq, qv( 1, DBI::SQL_INT ) ],
\&        where => [],
\&        order_by => [ \*(Aqt3.dont\*(Aq, \*(Aqt1.col4\*(Aq ],
\&        limit    => 2,
\&    );
\&
\&    $db\->txn( sub {
\&        # Anything you like, done inside a BEGIN/COMMIT pair, with
\&        # nested calls to txn() done inside a SAVEPOINT/RELEASE pair.
\&    })
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Sorry, this documentation is invalid or out of date.
.PP
\&\fBDBIx::ThinSQL\fR is an extension to the Perl Database Interface
(\s-1DBI\s0).  It is designed for complicated queries and efficient access
to results.  With an \s-1API\s0 that lets you easily write almost-raw \s-1SQL\s0,
DBIx::ThinSQL gives you unfettered access to the power and flexibility
of your underlying database. It aims to be a tool for programmers who
want their databases to work just as hard as their Perl scripts.
.PP
DBIx::ThinSQL gives you access to aggregate expressions, joins, nested
selects, unions and database-side operator invocations. Transactional
support is provided via DBIx::Connector.  Security conscious coders
will be pleased to know that all user-supplied values are bound
properly using \s-1DBI\s0 \*(L"\fIbind_param()\fR\*(R".  Binding binary data is handled
transparently across different database types.
.PP
DBIx::ThinSQL offers a couple of very simple Create, Retrieve, Update
and Delete (\s-1CRUD\s0) action methods.  These are designed to get you up and
running quickly when your query data is already inside a hash. The
methods are abstractions of the real \s-1API\s0, but should still read as much
as possible like \s-1SQL\s0.
.PP
Although rows can be retrieved from the database as simple objects,
DBIx::ThinSQL does not attempt to be an Object-Relational-Mapper (\s-1ORM\s0).
There are no auto-inflating columns or automatic joins and the code
size and speed reflect the lack of complexity.
.PP
DBIx::ThinSQL uses the light-weight Log::Any for logging.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
Works like a normal \s-1DBI\s0. Can be used with things like
DBIx::Connector to get nice transaction support.
.SH "DBH METHODS"
.IX Header "DBH METHODS"
.IP "xprepare" 4
.IX Item "xprepare"
Does a prepare but knows about bind values and quoted values.
.IP "xarray" 4
.IX Item "xarray"
Does a prepare but knows about bind values and quoted values.
.IP "xarrays" 4
.IX Item "xarrays"
Does a prepare but knows about bind values and quoted values.
.IP "xhash" 4
.IX Item "xhash"
Does a prepare but knows about bind values and quoted values.
.IP "xhashes" 4
.IX Item "xhashes"
Does a prepare but knows about bind values and quoted values.
.ie n .IP "insert(into => $table, values => \e%val) \-> Int" 4
.el .IP "insert(into => \f(CW$table\fR, values => \e%val) \-> Int" 4
.IX Item "insert(into => $table, values => %val) -> Int"
Insert a row into the database and return the number of rows affected.
.IP "update($table, set => \e%values, where => \e%expr) \-> Int" 4
.IX Item "update($table, set => %values, where => %expr) -> Int"
Update rows in the database and return the number of rows affected.
.Sp
This method is retricted to the wholesale replacement of column values
(no database-side calculations etc).  Multiple \s-1WHERE\s0 key/values are
only '\s-1AND\s0'd together. An 'undef' value maps to \s-1SQL\s0's \s-1NULL\s0 value.
.ie n .IP "delete(from => $table, where => \e%expr) \-> Int" 4
.el .IP "delete(from => \f(CW$table\fR, where => \e%expr) \-> Int" 4
.IX Item "delete(from => $table, where => %expr) -> Int"
Delete rows from the database and return the number of rows affected.
.ie n .IP "select(\e@columns, from => $table, where => \e%expr) \-> @Obj" 4
.el .IP "select(\e@columns, from => \f(CW$table\fR, where => \e%expr) \-> \f(CW@Obj\fR" 4
.IX Item "select(@columns, from => $table, where => %expr) -> @Obj"
Retrieve rows from the database as a list of objects in array context,
or a single object in scalar context. These objects (blessed into a
dynamically created class) have an accessor method for each column.
.Sp
The first argument to the \fIselect()\fR method must be either an array
reference of column names, or a single '*'. If the array reference is
given only the columns specified will be retrieved from the database.
.IP "txn( &coderef )" 4
.IX Item "txn( &coderef )"
Runs the &coderef subroutine inside an \s-1SQL\s0 transaction.  If &coderef
raises an exception then the transaction is rolled back and the error
gets re-thrown.
.Sp
Calls to \f(CW\*(C`txn\*(C'\fR can be nested. Savepoints will be used by nested \f(CW\*(C`txn\*(C'\fR
calls for databases that support them.
.SH "STH METHODS"
.IX Header "STH METHODS"
.IP "array \-> \s-1ARRAYREF\s0" 4
.IX Item "array -> ARRAYREF"
Insert a row into the database and return the number of rows affected.
.IP "arrays \-> \s-1ARRAYREF\s0" 4
.IX Item "arrays -> ARRAYREF"
.PD 0
.IP "arrays \-> \s-1LIST\s0" 4
.IX Item "arrays -> LIST"
.PD
Update rows in the database and return the number of rows affected.
This method is retricted to the wholesale replacement of column values
(no database-side calculations etc).  Multiple \s-1WHERE\s0 key/values are
only '\s-1AND\s0'd together. An 'undef' value maps to \s-1SQL\s0's \s-1NULL\s0 value.
.IP "hash \-> \s-1HASHREF\s0" 4
.IX Item "hash -> HASHREF"
Delete rows from the database and return the number of rows affected.
.IP "hashes \-> ARRAYREF[\s-1HASHREF\s0]" 4
.IX Item "hashes -> ARRAYREF[HASHREF]"
.PD 0
.IP "hashes \-> \s-1LIST\s0" 4
.IX Item "hashes -> LIST"
.PD
Delete rows from the database and return the number of rows affected.
.SH "CLASS FUNCTIONS"
.IX Header "CLASS FUNCTIONS"
The following functions can be exported individually or all at once
using the ':all' tag.  They all return an object which can be combined
with or used inside other functions.
.ie n .IP "bv( $value, [ $bind_type ] ) \-> DBIx::ThinSQL::BindValue" 4
.el .IP "bv( \f(CW$value\fR, [ \f(CW$bind_type\fR ] ) \-> DBIx::ThinSQL::BindValue" 4
.IX Item "bv( $value, [ $bind_type ] ) -> DBIx::ThinSQL::BindValue"
This function returns an object which tells DBIx::ThinSQL to bind
\&\f(CW$value\fR using a placeholder. The optional \f(CW$bind_type\fR is a database type
(integer, varchar, timestamp, bytea, etc) which will be converted to
the appropriate bind constant during a \fIprepare()\fR or \fIprepare_cached()\fR
call.
.ie n .IP "qv( $value )" 4
.el .IP "qv( \f(CW$value\fR )" 4
.IX Item "qv( $value )"
.PD 0
.IP "\s-1AND\s0" 4
.IX Item "AND"
.IP "\s-1OR\s0" 4
.IX Item "OR"
.ie n .IP "sql_and( @args ) \-> DBIx::ThinSQL::Expr" 4
.el .IP "sql_and( \f(CW@args\fR ) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_and( @args ) -> DBIx::ThinSQL::Expr"
.PD
Maps to \*(L"$arg1 \s-1AND\s0 \f(CW$arg2\fR \s-1AND\s0 ...\*(R".
.ie n .IP "sql_case( @stmts ) \-> DBIx::ThinSQL::Expr" 4
.el .IP "sql_case( \f(CW@stmts\fR ) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_case( @stmts ) -> DBIx::ThinSQL::Expr"
Wraps \f(CW@stmts\fR inside a \s-1CASE/END\s0 pair while converting arguments to
expressions where needed.
.Sp
.Vb 5
\&    sql_case(
\&        when => $actors\->name\->is_null,
\&        then => \*(AqNo Name\*(Aq,
\&        else => $actors\->name,
\&    )\->as(\*(Aqname\*(Aq)
\&
\&    # CASE WHEN actors0.name IS NULL
\&    # THEN ? ELSE actors0.name END AS name
.Ve
.IP "sql_coalesce(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_coalesce(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1COALESCE\s0($arg1, \f(CW$arg2\fR, ...)\*(R".
.ie n .IP "sql_cast($arg1, as => $arg2) \-> DBIx::ThinSQL::Expr" 4
.el .IP "sql_cast($arg1, as => \f(CW$arg2\fR) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_cast($arg1, as => $arg2) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1CAST\s0( \f(CW$arg1\fR \s-1AS\s0 \f(CW$arg2\fR )\*(R".
.IP "sql_concat(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_concat(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"$arg1 || \f(CW$arg2\fR || ...\*(R".
.IP "sql_count(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_count(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1COUNT\s0($arg1, \f(CW$arg2\fR, ...)\*(R".
.IP "sql_exists(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_exists(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1EXISTS\s0(@args)\*(R".
.ie n .IP "sql_func('myfunc', @args) \-> DBIx::ThinSQL::Expr" 4
.el .IP "sql_func('myfunc', \f(CW@args\fR) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_func('myfunc', @args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1MYFUNC\s0($arg1, \f(CW$arg2\fR, ...)\*(R".
.IP "sql_hex(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_hex(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1HEX\s0($arg1, \f(CW$arg2\fR, ...)\*(R".
.IP "sql_length(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_length(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1LENGTH\s0(@args)\*(R".
.IP "sql_lower(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_lower(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1LOWER\s0(@args)\*(R".
.IP "sql_ltrim(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_ltrim(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1LTRIM\s0(@args)\*(R".
.IP "sql_max(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_max(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1MAX\s0(@args)\*(R".
.IP "sql_min(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_min(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1MIN\s0(@args)\*(R".
.IP "sql_rtrim(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_rtrim(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1RTRIM\s0(@args)\*(R".
.IP "sql_sum(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_sum(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1MIN\s0(@args)\*(R".
.IP "sql_or(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_or(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"$arg1 \s-1OR\s0 \f(CW$arg2\fR \s-1OR\s0 ...\*(R".
.IP "sql_replace(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_replace(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1REPLACE\s0($arg1,$arg2 [,$arg3])\*(R".
.IP "sql_substr(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_substr(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1SUBSTR\s0($arg1, \f(CW$arg2\fR, ...)\*(R".
.ie n .IP "sql_table($name, @columns) \-> DBIx::ThinSQL::Expr" 4
.el .IP "sql_table($name, \f(CW@columns\fR) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_table($name, @columns) -> DBIx::ThinSQL::Expr"
Maps to \*(L"name(col1,col2,...)\*(R".
.IP "sql_upper(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_upper(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1UPPER\s0(@args)\*(R".
.IP "sql_values(@args) \-> DBIx::ThinSQL::Expr" 4
.IX Item "sql_values(@args) -> DBIx::ThinSQL::Expr"
Maps to \*(L"\s-1VALUES\s0($arg1, \f(CW$arg2\fR, ...)\*(R".
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Log::Any
.SH "DEVELOPMENT & SUPPORT"
.IX Header "DEVELOPMENT & SUPPORT"
DBIx::ThinSQL is managed via Github:
.PP
.Vb 1
\&    https://github.com/mlawren/p5\-DBIx\-ThinSQL/tree/devel
.Ve
.PP
DBIx::ThinSQL follows a semantic versioning scheme:
.PP
.Vb 1
\&    http://semver.org
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark Lawrence <nomad@null.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2013 Mark Lawrence <nomad@null.net>
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of the \s-1GNU\s0 General Public License as published by the
Free Software Foundation; either version 3 of the License, or (at your
option) any later version.

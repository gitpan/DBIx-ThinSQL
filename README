NAME
    DBIx::ThinSQL - SQL database interface for Perl

VERSION
    0.0.1 Development release.

SYNOPSIS
        use DBIx::ThinSQL;

        my $db = DBIx::ThinSQL->connect( 'dbi:...', 'username', 'password' );

        # The very simple stuff

        my $success = $db->insert(
            into   => 'actors',
            values => { id => 1, name => 'John Smith' },
        );

        my $count = $db->update(
            'actors',
            set   => { name => 'Jack Smith' },
            where => { id   => 1, name => 'John Smith' },
        );

        my $count = $db->delete(
            from  => 'actors',
            where => { actor_id => 1, last_name => 'Jones' },
        );

        my $row = $db->select(
            [ 'id', 'name' ],
            from  => 'actors',
            where => { id => 1 },
        );

        print $row->id . ':' . $row->name . "\n";


        # The do-any-SQL-you-want stuff

        my $people = $db->irow('people');

        $db->do(
            insert_into => $people->( 'id', 'name' );
              sql_values( 1, 'A Name' ),
        );

        # Anyone celebrating a birthday today gets a raise, with the
        # calculation done inside the database.

        my $people = $db->urow('people');

        $db->do(
            update => $people,
            set    => $people->salary( $people->salary * 2 ),
            where  => $people->dob == $today,
        );

        my $purchases = $db->srow('purchases');

        my $row = $db->fetch1(
            select    => [ $people->name, $ps->pid ],
            from      => $people,
            left_join => $purchases,
            on        => $purchases->id == $people->id,
            where => $people->id->in( 1, 2, 3 ) 
              . AND
              . $people->name->like('%paul%'),
            limit  => 1,
            offset => 1,
        );

        # then do stuff with $row->pid, $row->name etc

        my @rows = $db->fetch(
            select => [ sql_coalesce( $p->pid, $p->cid )->as('pcid') ],
            from   => $p,
            where  => $p->cid->is_not_null,
        );

        # coalesce column is available as $row->pcid

        my $iter = $db->iter( @query ... );
        while ( my $row = $iter->next ) {
            print $row->col(), $row->some_other_column;
        }

        # If you want the data your own way you can still use the query
        # syntax:
        my $sth = $db->sth(@query);
        map { print join( ',', @$_ ) . "\n" } $sth->fetchall_arrayref;

        # Transactions provided by DBIx::Connector
        $db->txn(
            sub {

                # multiple statements
            }
        );

DESCRIPTION
    DBIx::ThinSQL is an extension to the Perl Database Interface (DBI). It
    is designed for complicated queries and efficient access to results.
    With an API that lets you easily write almost-raw SQL, DBIx::ThinSQL
    gives you unfettered access to the power and flexibility of your
    underlying database. It aims to be a tool for programmers who want their
    databases to work just as hard as their Perl scripts.

    DBIx::ThinSQL gives you access to aggregate expressions, joins, nested
    selects, unions and database-side operator invocations. Transactional
    support is provided via DBIx::Connector. Security conscious coders will
    be pleased to know that all user-supplied values are bound properly
    using DBI "bind_param()". Binding binary data is handled transparently
    across different database types.

    DBIx::ThinSQL offers a couple of very simple Create, Retrieve, Update
    and Delete (CRUD) action methods. These are designed to get you up and
    running quickly when your query data is already inside a hash. The
    methods are abstractions of the real API, but should still read as much
    as possible like SQL.

    Although rows can be retrieved from the database as simple objects,
    DBIx::ThinSQL does not attempt to be an Object-Relational-Mapper (ORM).
    There are no auto-inflating columns or automatic joins and the code size
    and speed reflect the lack of complexity.

    DBIx::ThinSQL uses the light-weight Log::Any for logging.

CONSTRUCTOR
    Works like a normal DBI. Can be used with things like DBIx::Connector to
    get nice transaction support.

DBH METHODS
    xprepare
        Does a prepare but knows about bind values and quoted values.

    xarray
        Does a prepare but knows about bind values and quoted values.

    xarrays
        Does a prepare but knows about bind values and quoted values.

    xhash
        Does a prepare but knows about bind values and quoted values.

    xhashes
        Does a prepare but knows about bind values and quoted values.

    insert(into => $table, values => \%val) -> Int
        Insert a row into the database and return the number of rows
        affected.

    update($table, set => \%values, where => \%expr) -> Int
        Update rows in the database and return the number of rows affected.

        This method is retricted to the wholesale replacement of column
        values (no database-side calculations etc). Multiple WHERE
        key/values are only 'AND'd together. An 'undef' value maps to SQL's
        NULL value.

    delete(from => $table, where => \%expr) -> Int
        Delete rows from the database and return the number of rows
        affected.

    select(\@columns, from => $table, where => \%expr) -> @Obj
        Retrieve rows from the database as a list of objects in array
        context, or a single object in scalar context. These objects
        (blessed into a dynamically created class) have an accessor method
        for each column.

        The first argument to the select() method must be either an array
        reference of column names, or a single '*'. If the array reference
        is given only the columns specified will be retrieved from the
        database.

STH METHODS
    array -> ARRAYREF
        Insert a row into the database and return the number of rows
        affected.

    arrays -> ARRAYREF
    arrays -> LIST
        Update rows in the database and return the number of rows affected.
        This method is retricted to the wholesale replacement of column
        values (no database-side calculations etc). Multiple WHERE
        key/values are only 'AND'd together. An 'undef' value maps to SQL's
        NULL value.

    hash -> HASHREF
        Delete rows from the database and return the number of rows
        affected.

    hashes -> ARRAYREF[HASHREF]
    hashes -> LIST
        Delete rows from the database and return the number of rows
        affected.

CLASS FUNCTIONS
    The following functions can be exported individually or all at once
    using the ':all' tag. They all return an object which can be combined
    with or used inside other functions.

    bv( $value, [ $bind_type ] ) -> DBIx::ThinSQL::BindValue
        This function returns an object which tells DBIx::ThinSQL to bind
        $value using a placeholder. The optional $bind_type is a database
        type (integer, varchar, timestamp, bytea, etc) which will be
        converted to the appropriate bind constant during a prepare() or
        prepare_cached() call.

    qv( $value )
    AND
    OR
    sql_and( @args ) -> DBIx::ThinSQL::Expr
        Maps to "$arg1 AND $arg2 AND ...".

    sql_case( @stmts ) -> DBIx::ThinSQL::Expr
        Wraps @stmts inside a CASE/END pair while converting arguments to
        expressions where needed.

            sql_case(
                when => $actors->name->is_null,
                then => 'No Name',
                else => $actors->name,
            )->as('name')

            # CASE WHEN actors0.name IS NULL
            # THEN ? ELSE actors0.name END AS name

    sql_coalesce(@args) -> DBIx::ThinSQL::Expr
        Maps to "COALESCE($arg1, $arg2, ...)".

    sql_cast($arg1, as => $arg2) -> DBIx::ThinSQL::Expr
        Maps to "CAST( $arg1 AS $arg2 )".

    sql_concat(@args) -> DBIx::ThinSQL::Expr
        Maps to "$arg1 || $arg2 || ...".

    sql_count(@args) -> DBIx::ThinSQL::Expr
        Maps to "COUNT($arg1, $arg2, ...)".

    sql_exists(@args) -> DBIx::ThinSQL::Expr
        Maps to "EXISTS(@args)".

    sql_func('myfunc', @args) -> DBIx::ThinSQL::Expr
        Maps to "MYFUNC($arg1, $arg2, ...)".

    sql_hex(@args) -> DBIx::ThinSQL::Expr
        Maps to "HEX($arg1, $arg2, ...)".

    sql_length(@args) -> DBIx::ThinSQL::Expr
        Maps to "LENGTH(@args)".

    sql_lower(@args) -> DBIx::ThinSQL::Expr
        Maps to "LOWER(@args)".

    sql_ltrim(@args) -> DBIx::ThinSQL::Expr
        Maps to "LTRIM(@args)".

    sql_max(@args) -> DBIx::ThinSQL::Expr
        Maps to "MAX(@args)".

    sql_min(@args) -> DBIx::ThinSQL::Expr
        Maps to "MIN(@args)".

    sql_rtrim(@args) -> DBIx::ThinSQL::Expr
        Maps to "RTRIM(@args)".

    sql_sum(@args) -> DBIx::ThinSQL::Expr
        Maps to "MIN(@args)".

    sql_or(@args) -> DBIx::ThinSQL::Expr
        Maps to "$arg1 OR $arg2 OR ...".

    sql_replace(@args) -> DBIx::ThinSQL::Expr
        Maps to "REPLACE($arg1,$arg2 [,$arg3])".

    sql_substr(@args) -> DBIx::ThinSQL::Expr
        Maps to "SUBSTR($arg1, $arg2, ...)".

    sql_table($name, @columns) -> DBIx::ThinSQL::Expr
        Maps to "name(col1,col2,...)".

    sql_upper(@args) -> DBIx::ThinSQL::Expr
        Maps to "UPPER(@args)".

    sql_values(@args) -> DBIx::ThinSQL::Expr
        Maps to "VALUES($arg1, $arg2, ...)".

SEE ALSO
    Log::Any

DEVELOPMENT & SUPPORT
    DBIx::ThinSQL is managed via Github:

        https://github.com/mlawren/p5-DBIx-ThinSQL/tree/devel

    DBIx::ThinSQL follows a semantic versioning scheme:

        http://semver.org

AUTHOR
    Mark Lawrence <nomad@null.net>

COPYRIGHT AND LICENSE
    Copyright (C) 2013 Mark Lawrence <nomad@null.net>

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 3 of the License, or (at your
    option) any later version.

